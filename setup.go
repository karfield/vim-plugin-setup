package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/codegangsta/cli"
	"github.com/ungerik/go-dry"
)

const _VIMRC_TEMPLATE = `
"
" THIS FILE IS GENERATED BY '{{.CMDNAME}}'
" DO NOT MIDIFY VIM CONFIGS HERE!
"
" If you want to change configs, Change directory to {{.CONFIGDIR}}
" Then you could modify/add/remove isolated vim configs
"
" {{.CMDNAME}} is a tool to help you manage vim plugins
" You can install plugin like this:
"	{{.CMDNAME}} install <plugin-name> [<other-plugin-list>]
"
" The actual plugin manage is using 'pathogen', it will autoload the other
" plugins which stored in {{.BUNDLEDIR}}
"
" After install one plugin, you could add some vim config in {{.CONFIGDIR}}
"
" For more information about {{.CMDNAME}}, use '-h' to print more help information
"
`

const _PATHOGEN_CONFIG = `

" Config for github.com/tpope/vim-pathogen
" 
execute pathogen#infect()
syntax on
filetype plugin indent on

`

const _PATHOGEN_VIM_URL = "https://raw.githubusercontent.com/tpope/vim-pathogen/master/autoload/pathogen.vim"

var _PATHOGEN_C_PATTERN = regexp.MustCompile("^\\s*exec(?:ute|)\\s+pathogen#.*")

func setupVimPlugins(c *cli.Context) error {
	vimDir := c.GlobalString("vimdir")
	vimrcPath := c.GlobalString("vimrc")
	bundleDir := path.Join(vimDir, "bundle")
	autoloadDir := path.Join(vimDir, "autoload")
	configDir := path.Join(vimDir, "configs")

	os.MkdirAll(bundleDir, 0755)
	os.MkdirAll(autoloadDir, 0755)
	os.MkdirAll(configDir, 0755)

	vimrcBuf := bytes.NewBuffer([]byte{})
	oldVimrcBuf := bytes.NewBuffer([]byte{})
	generatedVimrc := true

	if !dry.FileExists(vimrcPath) {
		tpl, _ := template.New("vimrc").Parse(_VIMRC_TEMPLATE)
		tpl.Execute(vimrcBuf, map[string]interface{}{
			"CONFIGDIR":   configDir,
			"BUNDLEDIR":   bundleDir,
			"AUTOLOADDIR": autoloadDir,
			"VIMRCFILE":   vimrcPath,
		})
	} else {
		oldVimrc, err := os.Open(vimrcPath)
		if err != nil {
			return err
		}
		defer oldVimrc.Close()
		oldVimrcBuf.Reset()
		scanner := bufio.NewScanner(oldVimrc)
		generated := false
		for scanner.Scan() {
			l := scanner.Text()
			if _PATHOGEN_C_PATTERN.MatchString(l) {
				// comment the pathongen config line(s)
				oldVimrcBuf.WriteString("\" ")
			}
			if strings.HasPrefix(l, "\" THIS FILE IS GENERATED BY ") {
				generated = true
			}
			oldVimrcBuf.WriteString(l)
			oldVimrcBuf.WriteString("\n")
		}
		generatedVimrc = generated
	}

	pathogenVim := path.Join(autoloadDir, "pathogen.vim")
	if !dry.FileExists(pathogenVim) {
		if err := installPathogen(pathogenVim); err != nil {
			return err
		}
		vimrcBuf.WriteString(_PATHOGEN_CONFIG)
	}

	if !generatedVimrc {
		// save the user defined old vimrc into config-dir
		oldVimrcFile := path.Join(configDir, "__old_config.vimrc")
		saveConfig(oldVimrcFile, oldVimrcBuf)
		// save prebuilt-included vim configs except common.vimrc
		for _confPath, confData := range _bindata {
			fn := path.Base(_confPath)
			if fn == "_common.vimrc" {
				continue
			}
			saveConfig(path.Join(configDir, fn), confData)
		}
	} else {
		// save common and prebuilt-included vim configs
		for _confPath, confData := range _bindata {
			confPath := path.Join(configDir, path.Base(_confPath))
			saveConfig(confPath, confData)
		}
	}

	return installPluginsByConfigs(vimrcBuf, vimrcPath, configDir, bundleDir)
}

func saveConfig(_path string, _data interface{}) bool {
	if data, ok := _data.(*bytes.Buffer); ok {
		var file *os.File
		var err error
		if dry.FileExists(_path) {
			file, err = os.Open(_path)
		} else {
			file, err = os.Create(_path)
		}
		if err != nil {
			return false
		}

		w := bufio.NewWriter(file)
		io.Copy(w, data)
		if err := w.Flush(); err != nil {
			return false
		}
		return true
	} else if data, ok := _data.([]byte); ok {
		return ioutil.WriteFile(_path, data, 0644) == nil
	} else if data, ok := _data.(string); ok {
		return ioutil.WriteFile(_path, []byte(data), 0644) == nil
	}
	return false
}

func installPathogen(installPath string) error {
	if resp, err := http.Get(_PATHOGEN_VIM_URL); err != nil {
		return err
	} else {
		defer resp.Body.Close()
		pathogen, err := os.Create(installPath)
		if err != nil {
			return err
		}
		defer pathogen.Close()
		if _, err := io.Copy(pathogen, resp.Body); err != nil {
			return err
		}
	}
	return nil
}

var _INSTALL_SCRIPT_BEGIN_PATTERN = regexp.MustCompile("\\s*\"\\s+run-script\\s*(?:\\(([^\\)]*)\\)|)")
var _INSTALL_SCRIPT_END_PATTERN = regexp.MustCompile("\\s*\"\\s+end-script")
var _INSTALL_SCRIPT_LINE_PATTERN = regexp.MustCompile("\\s*\"(.*)")
var _INSTALL_PLUGIN_PATTERN = regexp.MustCompile("\\s*\"\\s+require-plugin\\s*:\\s*(.*)")

func installPluginsByConfigs(vimrcBuf *bytes.Buffer, vimrcPath, configDir, bundleDir string) error {
	fl, err := dry.ListDirFiles(configDir)
	if err != nil {
		return err
	}
	for _, f := range fl {
		if strings.HasPrefix(f, "_") {
			continue
		}

		configfile := path.Join(configDir, f)
		err := installPuginByConfig(vimrcBuf, bundleDir, configfile)
		if err != nil {
			continue
		}

		relPath, err := filepath.Rel(vimrcPath, configfile)
		if err != nil {
			continue
		}
		sourcefrom := "source " + relPath + "\n"
		if _, err := vimrcBuf.WriteString(sourcefrom); err != nil {
			continue
		}
	}
	return nil
}

func installPuginByConfig(vimrcBuf *bytes.Buffer, bundleDir, configFilepath string) error {
	file, err := os.Open(configFilepath)
	if err != nil {
		return err
	}
	defer file.Close()

	installScript := bytes.NewBufferString("")
	plugins := []string{}

	scanner := bufio.NewScanner(file)

	scriptBegin := false
	scriptEnd := false
	scriptExector := ""

	for scanner.Scan() {
		line := scanner.Text()
		if _INSTALL_SCRIPT_BEGIN_PATTERN.MatchString(line) {
			scriptBegin = true
			scriptEnd = false
			ss := _INSTALL_SCRIPT_BEGIN_PATTERN.FindStringSubmatch(line)
			scriptExector = ss[1]
			continue
		}
		if _INSTALL_SCRIPT_END_PATTERN.MatchString(line) {
			scriptBegin = false
			scriptEnd = true
			continue
		}
		if _INSTALL_PLUGIN_PATTERN.MatchString(line) {
			ss := _INSTALL_PLUGIN_PATTERN.FindStringSubmatch(line)
			plugins = append(plugins, ss[1])
			continue
		}
		if scriptBegin && !scriptEnd {
			ss := _INSTALL_SCRIPT_LINE_PATTERN.FindStringSubmatch(line)
			if len(ss) > 0 {
				installScript.WriteString(ss[1])
				installScript.WriteString("\n")
			}
		}
	}

	for _, plugin := range plugins {
		fmt.Println("install plugin: ", plugin)
		if err := installPlugin(bundleDir, plugin); err != nil {
			return err
		}
	}

	if installScript.Len() > 0 {
		tmpDir, err := ioutil.TempDir("", "")
		if err != nil {
			return err
		}
		tmpfile, err := ioutil.TempFile(tmpDir, ".vim-setup-script-")
		if err != nil {
			return err
		}
		defer tmpfile.Close()
		if _, err := io.WriteString(tmpfile, installScript.String()); err != nil {
			return err
		}
		scriptFilepath := path.Join(tmpDir, tmpfile.Name())

		if scriptExector == "" {
			scriptExector = "/bin/bash"
		}

		cmd := exec.Command(scriptExector, scriptFilepath)
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return err
		}
	}

	return nil
}
